# -*- coding: utf-8 -*-
"""Neural Network.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1izOed7kgc0kuDDmE01vIw7ckfbgMeRxs

## Forward Pass
"""

def fpass(weight,x1,x2,b1,b2,T1,T2):
    Neth1 = (weight[0]*x1)+(weight[1]*x2)+b1
    Outh1 = 1/(1+(2.718281828459045**(-Neth1)))
#     print("Net h1 is:",Neth1)
#     print("Out h1 is:",Outh1)
    Neth2 = (weight[2]*x1)+(weight[3]*x2)+b1
    Outh2 = 1/(1+(2.718281828459045**(-Neth2)))
#     print("Net h2 is:",Neth2)
#     print("Out h2 is:",Outh2)
    Nety1 = (weight[4]*Outh1)+(weight[5]*Outh2)+b2
    Outy1 = 1/(1+(2.718281828459045**(-Nety1)))
#     print("Net y1 is:",Nety1)
    print("Output of y1 is:",Outy1)
    Nety2 = (weight[6]*Outh1)+(weight[7]*Outh2)+b2
    Outy2 = 1/(1+(2.718281828459045**(-Nety2)))
#     print("Net y2 is:",Nety2)
    print("Output of y2 is:",Outy2)
       #Calculating error
    Ey1 = ((T1-Outy1)**2)/2
    Ey2 = ((T2-Outy2)**2)/2
    Etotal = Ey1 + Ey2
    print("Total Error is:",Etotal)
    return weight,Neth1,Outh1,Neth2,Outh2,Nety1,Outy1,Nety2,Outy2,Etotal

"""## New weight value"""

def newweight(W,dw):
    eta= 0.5
    nw= W-eta*dw
    return nw



"""## Partial Derivatives"""

def pder(x1,x2,Ty1,Ty2,W,Neth1,Outh1,Neth2,Outh2,Nety1,Outy1,Nety2,Outy2,Etotal):
    # ∂Etotal/∂w56 = ∂Etotal/∂Outy1 * ∂Outy1/∂Nety1 * ∂Nety1/∂w56
    dEtOy1 = -Ty1 + Outy1
    dOy1Ny1 = Outy1 * (1 - Outy1)
    dNy1w5 = Outh1
    dNy1w6 = Outh2
    # ∂Etotal/∂w78 = ∂Etotal/∂Outy1 * ∂Outy1/∂Nety1 * ∂Nety1/∂w78
    dEtOy2 = -Ty2 + Outy2
    dOy2Ny2 = Outy2 * (1 - Outy2)
    dNy1w7 = Outh1
    dNy1w8 = Outh2
    # ∂Etotal/∂w12 = ∂Etotal/∂Outh1 * ∂Outh1/∂Neth1 * ∂Neth1/∂w12
    # ∂Etotal/∂Outh1= ∂Ey1/∂Outh1 + ∂Ey2/∂Outh1
    # ∂Ey1/∂Outh1 = ∂Ey1/∂Outy1 * ∂Outy1/∂Nety1 * ∂Nety1/∂Outh1
    dEy1Outh1= (-Ty1 + Outy1) * (Outy1 * (1 - Outy1)) * W[4]
    # ∂Ey2/∂Outh1 = ∂Ey2/∂Outy2 * ∂Outy2/∂Nety2 * ∂Nety2/∂Outh1
    dEy2Outh1= (-Ty2 + Outy2) * (Outy2 * (1 - Outy2)) * W[6]
    dOh1Nh1 = Outh1 * (1 - Outh1)
    dNh1w1 = x1
    dNh1w2 = x2
    # ∂Etotal/∂w34 = ∂Etotal/∂Outh2 * ∂Outh2/∂Neth2 * ∂Neth2/∂w34
    # ∂Etotal/∂Outh2= ∂Ey1/∂Outh2 + ∂Ey2/∂Outh2
    # ∂Ey1/∂Outh2 = ∂Ey1/∂Outy1 * ∂Outy1/∂Nety1 * ∂Nety1/∂Outh2
    dEy1Outh2= (-Ty1 + Outy1) * (Outy1 * (1 - Outy1)) * W[5]
    # ∂Ey2/∂Outh2 = ∂Ey2/∂Outy2 * ∂Outy2/∂Nety2 * ∂Nety2/∂Outh2
    dEy2Outh2= (-Ty2 + Outy2) * (Outy2 * (1 - Outy2)) * W[7]
    dOh2Nh2 = Outh2 * (1 - Outh2)
    dNh2w3 = x1
    dNh2w4 = x2
    return dEtOy1,dOy1Ny1,dNy1w5,dNy1w6,dEtOy2,dOy2Ny2,dNy1w7,dNy1w8,dEy1Outh1,dEy2Outh1,dOh1Nh1,dNh1w1,dNh1w2,dEy1Outh2,dEy2Outh2,dOh2Nh2,dNh2w3,dNh2w4

"""## Backward Propogation"""

def backp(W,dEtOy1,dOy1Ny1,dNy1w5,dNy1w6,dEtOy2,dOy2Ny2,dNy1w7,dNy1w8,dEy1Outh1,dEy2Outh1,dOh1Nh1,dNh1w1,dNh1w2,dEy1Outh2,dEy2Outh2,dOh2Nh2,dNh2w3,dNh2w4,x1,x2,b1,b2,Ty1,Ty2):
    dw5 = dEtOy1 * dOy1Ny1 * dNy1w5
    dw6 = dEtOy1 * dOy1Ny1 * dNy1w6
    dw7 = dEtOy2 * dOy2Ny2 * dNy1w7
    dw8 = dEtOy2 * dOy2Ny2 * dNy1w8    
    dw1 = (dEy1Outh1 + dEy2Outh1) * dOh1Nh1 * dNh1w1
    dw2 = (dEy1Outh1 + dEy2Outh1) * dOh1Nh1 * dNh1w2
    dw3 = (dEy1Outh2 + dEy2Outh2) * dOh2Nh2 * dNh2w3
    dw4 = (dEy1Outh2 + dEy2Outh2) * dOh2Nh2 * dNh2w4
#     print("dw5 is",dw5)
#     print("dw6 is",dw6)
#     print("dw7 is",dw7)
#     print("dw8 is",dw8)
#     print("dw1 is",dw1)
#     print("dw2 is",dw2)
#     print("dw3 is",dw3)
#     print("dw4 is",dw4)
    w1= [newweight(W[0],dw1),newweight(W[1],dw2),newweight(W[2],dw3),newweight(W[3],dw4),newweight(W[4],dw5),newweight(W[5],dw6),newweight(W[6],dw7),newweight(W[7],dw8)]
#     w1[0]= newweight(W[0],dw1)
#     w1[1]= newweight(W[1],dw2)
#     w1[2]= newweight(W[2],dw3)
#     w1[3]= newweight(W[3],dw4)
#     w1[4]= newweight(W[4],dw5)
#     w1[5]= newweight(W[5],dw6)
#     w1[6]= newweight(W[6],dw7)
#     w1[7]= newweight(W[7],dw8)
    print(w1)
    weight,Neth1,Outh1,Neth2,Outh2,Nety1,Outy1,Nety2,Outy2,Etotal=fpass(w1,x1,x2,b1,b2,Ty1,Ty2)
    return weight,Neth1,Outh1,Neth2,Outh2,Nety1,Outy1,Nety2,Outy2,Etotal

"""## Initializing Values & Function Call"""

x1 = 0.05 #float(input("Enter value of X1: "))
x2 = 0.10 #float(input("Enter value of X2: "))
Ty1= 0.01 
Ty2= 0.99
W = [0.15,0.20,0.25,0.30,0.40,0.45,0.50,0.55]
# for i in range(0,8):
#     w= float(input(f"Enter value for w{i+1}: "))
#     W.append(w)
b1 = 0.35 #float(input("Enter the value of bias1: "))
b2 = 0.60 #float(input("Enter the value of bias2: "))
# print(x1)
# print(x2)
# print(W)
weight,Neth1,Outh1,Neth2,Outh2,Nety1,Outy1,Nety2,Outy2,Etotal= fpass(W,x1,x2,b1,b2,Ty1,Ty2)
dEtOy1,dOy1Ny1,dNy1w5,dNy1w6,dEtOy2,dOy2Ny2,dNy1w7,dNy1w8,dEy1Outh1,dEy2Outh1,dOh1Nh1,dNh1w1,dNh1w2,dEy1Outh2,dEy2Outh2,dOh2Nh2,dNh2w3,dNh2w4 = pder(x1,x2,Ty1,Ty2,W,Neth1,Outh1,Neth2,Outh2,Nety1,Outy1,Nety2,Outy2,Etotal)

inp= int(input("Enter number of iterations: "))
for i in range(inp):
    weight,Neth1,Outh1,Neth2,Outh2,Nety1,Outy1,Nety2,Outy2,Etotal= backp(weight,dEtOy1,dOy1Ny1,dNy1w5,dNy1w6,dEtOy2,dOy2Ny2,dNy1w7,dNy1w8,dEy1Outh1,dEy2Outh1,dOh1Nh1,dNh1w1,dNh1w2,dEy1Outh2,dEy2Outh2,dOh2Nh2,dNh2w3,dNh2w4,x1,x2,b1,b2,Ty1,Ty2)
    dEtOy1,dOy1Ny1,dNy1w5,dNy1w6,dEtOy2,dOy2Ny2,dNy1w7,dNy1w8,dEy1Outh1,dEy2Outh1,dOh1Nh1,dNh1w1,dNh1w2,dEy1Outh2,dEy2Outh2,dOh2Nh2,dNh2w3,dNh2w4 = pder(x1,x2,Ty1,Ty2,weight,Neth1,Outh1,Neth2,Outh2,Nety1,Outy1,Nety2,Outy2,Etotal)



